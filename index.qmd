---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

:::: {.callout-important}
## ðŸ“‹ What You Need To Do

- [ ] Fork and create repo `simulationChallenge` in your GitHub
- [ ] Clone locally and open in Cursor
- [ ] Write your analysis in this `index.qmd`
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/simulationChallenge/`
:::

:::: {.callout-warning}
## âš ï¸ AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain the results in your own words.  Verify cursor's calculations as investment simulation is tricky.
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

::::: {.callout-note}
## Grading Scope

- Sections 1â€“4: required and can earn up to 90% of the grade.
- Sections 5â€“6: optional; strong, well-supported work here can bring your score up to 100%.
::::

### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is >, =, or < $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?

```{python}
#| label: q1-expected-value-py
#| echo: false

# TODO: Compute EV after one flip in Python
# - Show calculation and brief explanation
W0 = 30_000  # initial wealth
p_head = 0.5
mult_head = 1.5
mult_tail = 0.6

# Expected value after one flip: E[W1] = W0 * (p_head*mult_head + (1-p_head)*mult_tail)
ev_multiplier = p_head * mult_head + (1 - p_head) * mult_tail
ev_after_one = W0 * ev_multiplier

gain_abs = ev_after_one - W0
gain_pct = ev_after_one / W0 - 1

print(f"Expected value after one flip: ${ev_after_one:,.2f}")
print(f"Gain vs buy-in: ${gain_abs:,.2f} ({gain_pct:.1%})")
print("Explanation: With a fair coin, EV multiplier = 0.5*1.5 + 0.5*0.6 = 1.05, so EV = 30,000 * 1.05 = 31,500.")
```
**Explanation:** The expected value (EV) after one flip is higher than my initial buy-in of $30,000. This is because the game is designed so that, on average, my money grows by 5% per flip (EV multiplier = 1.05). Even though I can lose 40% on tails, the chance to gain 50% on heads makes up for it in expectation. Therefore, the gain in expected value as a percentage of my buy-in is 5%. This simple EV analysis suggests that, *on average*, **buying in is favorable**. However, this does not account for the risk (variance) or what can happen over repeated flipsâ€”only the *average* outcome after one flip.

### 2) Single Simulation Over Time (Narrative + Plot)

Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance"

# TODO: Simulate one path from $30,000 over N periods
# - Make a matplotlib (OO) time-series
# - Set seed for reproducibility
import numpy as np
import matplotlib.pyplot as plt

# Parameters
W0 = 30_000
N = 40  # number of periods (years)
p_head = 0.5
mult_head = 1.5
mult_tail = 0.6

# Reproducibility
rng = np.random.default_rng(42)

# Simulate coin flips: 1 = heads, 0 = tails
flips = rng.integers(0, 2, size=N)
multipliers = np.where(flips == 1, mult_head, mult_tail)

# Wealth path
wealth = np.empty(N + 1, dtype=float)
wealth[0] = W0
wealth[1:] = W0 * np.cumprod(multipliers)
#print(np.cumprod(multipliers))
# Plot (OO style)
t = np.arange(N + 1)
fig, ax = plt.subplots(figsize=(7, 4))
ax.plot(t, wealth, marker='o', linewidth=1.6, label='Wealth path')
ax.axhline(W0, color='gray', linestyle='--', linewidth=1, label='Buy-in $30,000')
ax.set_xlabel('Period')
ax.set_ylabel('Balance ($)')
ax.set_title('Single simulation path of account balance')
ax.grid(True, alpha=0.3)
ax.legend()

print(f"Final balance after {N} periods: ${wealth[-1]:,.2f}")
print(f"Heads: {flips.sum()}, Tails: {N - flips.sum()}")

# Add age markers to the x-axis to reflect years since age 35
initial_age = 35
ax.set_xticks([0, 5, 10, 15, 20, 25, 30, 35, 40])
ax.set_xticklabels([str(initial_age + i) for i in ax.get_xticks()])
ax.set_xlabel('Age')
ax.annotate('Start (age 35)', xy=(0, W0), xytext=(2, W0*1.2),
            arrowprops=dict(facecolor='black', arrowstyle='->'), fontsize=9)


```

**Explanation:** This single simulation shows the volatility inherent in this betting approach. Even with a fair coin, compounding gains and losses at these multipliers leads to very variable results. In this particular run, the final wealth may be far above, below, or near the starting $30,000; it's determined by the sequence of heads and tails. The path on the plot often shows sharp drops or gains after unlucky or lucky streaks. I might **not be happy with the outcome if because of large swings** or the risk of a big lossâ€”since some single simulations can wipe out much of the account, while others hit large gains. This risk profile is a direct result of risking so much each period, which is visually clear from the "spiky" path of the balance over time.

### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?

# Run 100 simulations and plot histogram of final balances
```{python}
#| label: q3-dist-100-py1
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

# TODO: Run 100 simulations and plot histogram of final balances
# - Add vertical line at $30,000
# - Compute mean, median, and P(final > $30,000)


N = 40  # number of periods (years) till age 75
mult_head = 1.5
mult_tail = 0.6
num_sims = 100
final_balances = []

np.random.seed(123)



# Use the single simulation logic for each simulation
for _ in range(num_sims):
    balance = 30_000
    for _ in range(N):
      flips = np.random.binomial(1, 0.5)
      if flips == 1:
        balance *= mult_head
      else:
        balance *= mult_tail
    
    final_balances.append(balance)

fig2, ax2 = plt.subplots(figsize=(7, 5))
ax2.hist(final_balances, bins=20,  edgecolor='black')
#ax2.hist(final_balances, bins=log_bins, color='deepskyblue', edgecolor='black', alpha=0.7)


# Calculate log-spaced bins for better separation of lower and higher balances
min_final = min(final_balances)
max_final = max(final_balances)
if min_final <= 0:
    min_final = 1  # To avoid log(0) or log(negative), set to 1 if needed

log_bins = np.logspace(np.log10(min_final), np.log10(max_final), 20)
mean_final = np.mean(final_balances)
median_final = np.median(final_balances)

# Add mean and median to legend - will update legend label for ax2.axvline below
mean_label = f"Mean: ${mean_final:,.0f}"
median_label = f"Median: ${median_final:,.0f}"

ax2.clear() 
# Draw lines for mean and median
ax2.axvline(mean_final, color='green', linestyle='--', linewidth=2, label=mean_label)
ax2.axvline(median_final, color='orange', linestyle=':', linewidth=2, label=median_label)

#print(min_final)
#print(max_final)
#print(final_balances)
 # Clear existing plot
ax2.hist(final_balances, bins=log_bins, edgecolor='black', color='deepskyblue', alpha=0.7)
ax2.axvline(30_000, color='red', linestyle='--', linewidth=2, label='$30,000 Start')
ax2.set_xscale('log')
ax2.set_xlabel('Final Balance ($)')
ax2.set_ylabel('Frequency')
ax2.set_title('Distribution of Final Balances (100 simulations, log scale)')
ax2.legend()

from matplotlib.ticker import FuncFormatter

def dollar_format(x, pos):
    # Format axis tick labels as dollar amounts with no decimals and thousands separator
    if x >= 1000:
        return f'${int(x):,}'
    else:
        return f'${int(x)}'

ax2.xaxis.set_major_formatter(FuncFormatter(dollar_format))

```

**Interpretation:** The distribution of final balances shows a wide range of outcomes, with most simulations ending below the initial buy-in of $30,000. The mean final balance is $33,215.02, and the median final balance is $3,647.30. The probability of final balances exceeding $30,000 is 0.220, meaning that only about 26% of simulations result in a final balance above the initial buy-in. This suggests that the game is highly risky, and the chances of losing money are relatively high.





### 4) Probability Balance > $30,000 at Age 75 (Original Game)

TODO: Report the probability estimate and interpret its practical meaning.
```{python}
#| label: q4-prob-original-py
#| echo: false
#| fig-cap: "Probability of final balance > $30,000 at age 75 (original game)"

# TODO: Using the 100 simulations above, estimate P(final > 30000)
# - Print numeric result with 3 decimals
import numpy as np

# Run test using a for loop as in section 3 to estimate P(final > $30,000)

final_balances_orig = np.array(final_balances)
final_balances_check = np.mean(final_balances_orig > W0)
print(f"Estimated P(final balance > $30,000): {final_balances_check:.3f}")
print(f"\nInterpretation: {final_balances_check:.1%} of simulations resulted in a final balance above the initial buy-in of ${W0:,.0f}.")

```
**Interpretation:** 26% of simulations resulted in a final balance above the initial buy-in of $30,000.


### 5) Modified Strategy (Bet Exactly 50% Each Round)

  Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

  # Let's simulate the modified strategy using a for loop, as was suggested in section 3.
import numpy as np
```{python}
#| label: q5-modified-50pct-py1
#| echo: false
#| fig-cap: "Modified strategy distribution (bet 50% each round)"

W0 = 30_000
N = 40
num_sims = 100
p_head = 0.5
bet_fraction = 0.25  # 25% bet per round
mult_head = 1.5
mult_tail = 0.6

mod_mult_head = (1 - bet_fraction) + bet_fraction * mult_head
mod_mult_tail = (1 - bet_fraction) + bet_fraction * mult_tail

rng = np.random.default_rng(456)
final_balances_mod = []

for _ in range(num_sims):
    w = W0
    for _ in range(N):
        if rng.random() < p_head:
            w *= mod_mult_head
        else:
            w *= mod_mult_tail
    final_balances_mod.append(w)

final_balances_mod = np.array(final_balances_mod)
prob_mod_loop = np.mean(final_balances_mod > W0)

print(f"(Estimated P(final balance > ${W0:,.0f}): {prob_mod_loop:.3f}")

# Statistics
prob_mod = np.mean(final_balances_mod > W0)
prob_orig = np.mean(final_balances_orig > W0)
mean_mod = final_balances_mod.mean()
mean_orig = final_balances_orig.mean()
median_mod = np.median(final_balances_mod)
median_orig = np.median(final_balances_orig)

print("Modified Strategy (25% bet) Statistics:")
print(f"  Mean final balance: ${mean_mod:,.2f}")
print(f"  Median final balance: ${median_mod:,.2f}")
print(f"  P(final > ${W0:,.0f}): {prob_mod:.1%}")
print(f"\nOriginal Strategy (100% bet) Statistics:")
print(f"  Mean final balance: ${mean_orig:,.2f}")
print(f"  Median final balance: ${median_orig:,.2f}")
print(f"  P(final > ${W0:,.0f}): {prob_orig:.1%}")

min_final = min(final_balances_orig)
max_final = max(final_balances_orig)

if min_final <= 0:
    min_final = 1  # To avoid log(0) or log(negative), set to 1 if needed

log_bins = np.logspace(np.log10(min_final), np.log10(max_final), 20)
mean_final = np.mean(final_balances_orig)
median_final = np.median(final_balances_orig)

# Add mean and median to legend - will update legend label for ax2.axvline below
mean_label = f"Mean: ${mean_final:,.0f}"
median_label = f"Median: ${median_final:,.0f}"


# Side-by-side histogram comparison: original vs modified strategy

fig_side, (ax_mod, ax_orig) = plt.subplots(1, 2, figsize=(8,6), sharey=True)

# Modified strategy
min_mod = min(final_balances_mod)
max_mod = max(final_balances_mod)
if min_mod <= 0:
    min_mod = 1
log_bins_mod = np.logspace(np.log10(min_mod), np.log10(max_mod), 20)
mean_mod = np.mean(final_balances_mod)
median_mod = np.median(final_balances_mod)

ax_mod.hist(final_balances_mod, bins=log_bins_mod, edgecolor='black', color='mediumseagreen', alpha=0.7)
ax_mod.axvline(mean_mod, color='green', linestyle='--', linewidth=2, label=f"Mean: ${mean_mod:,.0f}")
ax_mod.axvline(median_mod, color='orange', linestyle=':', linewidth=2, label=f"Median: ${median_mod:,.0f}")
ax_mod.axvline(30_000, color='red', linestyle='--', linewidth=2, label='$30,000 Start')
ax_mod.set_xscale('log')
ax_mod.set_xlabel('Final Balance ($)')
ax_mod.set_ylabel('Frequency')
ax_mod.set_title('Modified Strategy (25% bet each round)')
ax_mod.legend()
ax_mod.xaxis.set_major_formatter(FuncFormatter(dollar_format))

# Adjust subplot spacing to reduce x-axis label overlap
fig_side.subplots_adjust(wspace=0.25, bottom=0.13)
# Optionally, rotate x-axis tick labels for readability
for ax in (ax_mod, ax_orig):
    plt.sca(ax)
    plt.xticks(rotation=25)

# Original strategy
min_orig = min(final_balances_orig)
max_orig = max(final_balances_orig)
if min_orig <= 0:
    min_orig = 1
log_bins_orig = np.logspace(np.log10(min_orig), np.log10(max_orig), 20)
mean_orig = np.mean(final_balances_orig)
median_orig = np.median(final_balances_orig)

ax_orig.hist(final_balances_orig, bins=log_bins_orig, edgecolor='black', color='deepskyblue', alpha=0.7)
ax_orig.axvline(mean_orig, color='green', linestyle='--', linewidth=2, label=f"Mean: ${mean_orig:,.0f}")
ax_orig.axvline(median_orig, color='orange', linestyle=':', linewidth=2, label=f"Median: ${median_orig:,.0f}")
ax_orig.axvline(30_000, color='red', linestyle='--', linewidth=2, label='$30,000 Start')
ax_orig.set_xscale('log')
ax_orig.set_xlabel('Final Balance ($)')
ax_orig.set_title('Original Strategy (100% bet each round)')
ax_orig.legend()
ax_orig.xaxis.set_major_formatter(FuncFormatter(dollar_format))

fig_side.suptitle("Distribution of Final Balances: Modified vs Original Strategy (log scale)", fontsize=16)
fig_side.tight_layout(rect=[0, 0, 1, 0.96])

```


  **Explanation:** The modified strategy (25% bet each round) has a higher mean and median final balance than the original strategy (100% bet each round). The modified strategy also has a higher probability of final balance exceeding $30,000 than the original strategy. 


### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
What is the Kelly Criterion and how does it relate to the modified strategy?

::: {.callout-note title="Brief Explanation: Kelly Criterion & This Simulation"}
The **Kelly Criterion** is a mathematical formula used to determine the *optimal* size of a series of bets to maximize the long-term growth rate of your wealth, while managing risk of ruin. The criterion balances risk and reward: betting too much risks losing everything, while betting too little results in slower growth.

The Kelly fraction for a favorable bet is:

$$
f^* = \frac{p \cdot b - (1-p) \cdot a}{b}
$$

where:
- $p$ is the probability of winning,
- $b$ is the net fraction won (e.g., double-or-nothing: $b=1$),
- $a$ is the fraction lost if you lose (e.g., lose all: $a=1$).

**Relation to Our Strategies**:
- The *original* strategy risks 100% of the wealth per flip ("all or nothing" bets) â€” much larger than the Kelly recommendation. This maximizes variance and risk of total loss.
- The *modified* strategy, betting 25%, is closer to the Kelly optimal for an even-odds coin flip ($p=0.5$). In fact, the true Kelly bet is 0% for a fair coin (!), since $f^* = (0.5*1 - 0.5*1)/1 = 0$.
- **Findings**: The simulation showed that the original strategy suffers frequent total loss (low median; many outcomes below starting capital), while the smaller bet size reduces risk, resulting in *higher median outcomes* and a much larger probability of finishing above your initial wealth ($W_0$).

**Key Insight:**  
Risking your full bankroll (original strategy) leads to high risk and frequent loss. Betting a *smaller fraction* of capital, especially one recommended by the Kelly Criterion, allows for more consistent gains and much lower risk of ruin, even if the expected value remains the same for a fair coin. Kelly betting is an *optimal compromise* for long-term growth: maximizing wealth over time while minimizing the risk of going broke.
:::




## Professional Presentation (From Grading TLDR)

- **Clear narrative:** tell the story succinctly (aim for a 1â€“5 minute read)
- **Focus on insights:** risk profiles, counter-intuitive results, practical implications
- **Professional style:** concise writing, clean visuals, hide code where appropriate (`echo: false`)
- **Human interpretation:** explain what results mean for real decisions

## Submission Checklist âœ…

- [ ] Quarto document written with narrative and results
- [ ] Rendered to HTML successfully
- [ ] Repository `simulationChallenge` created on GitHub
- [ ] HTML committed and pushed
- [ ] GitHub Pages enabled (Deploy from a branch â†’ main â†’ /(root))
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

## Tips

- Set random seeds for reproducibility
- Use object-oriented plotting with `matplotlib`
- Keep figures readable and labeled; prefer professional styling
- Commit early and often; render locally before pushing

